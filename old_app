# motioneye_clone/app.py
from flask import Flask, render_template, Response, request, redirect, url_for, send_from_directory, jsonify
from camera import CameraHandler
import threading, os, subprocess

app = Flask(__name__)
camera_handler = CameraHandler()

@app.route('/')
def index():
    return render_template(
        'index.html',
        settings=camera_handler.get_settings(),
        resolutions=camera_handler.get_available_resolutions(),
        recording=camera_handler.is_recording(),
        timelapse=camera_handler.is_timelapse_running()
    )

@app.route('/video_feed')
def video_feed():
    return Response(camera_handler.gen_frames(), mimetype='multipart/x-mixed-replace; boundary=frame')

@app.route('/take_photo')
def take_photo():
    camera_handler.take_photo()
    return redirect(url_for('index'))

@app.route('/start_recording')
def start_recording():
    camera_handler.start_recording()
    return redirect(url_for('index'))

@app.route('/stop_recording')
def stop_recording():
    camera_handler.stop_recording()
    return redirect(url_for('index'))

@app.route('/update_settings', methods=['POST'])
def update_settings():
    preview_res = request.form.get('preview_res')
    photo_res = request.form.get('photo_res')
    white_balance = request.form.get('white_balance')
    interval = request.form.get('interval')
    duration_minutes = request.form.get('duration_minutes')
    rotation = request.form.get('rotation')
    camera_handler.update_settings(preview_res, photo_res, white_balance, interval, duration_minutes, rotation)
    return redirect(url_for('index'))

@app.route('/start_timelapse')
def start_timelapse():
    camera_handler.start_timelapse()
    return redirect(url_for('index'))

@app.route('/stop_timelapse')
def stop_timelapse():
    camera_handler.stop_timelapse()
    return redirect(url_for('index'))

@app.route('/gallery/photos')
def gallery_photos():
    photo_files = []
    folders = set()
    for root, dirs, files in os.walk('photos'):
        for file in sorted(files):
            if file.endswith('.jpg'):
                rel_dir = os.path.relpath(root, 'photos')
                rel_path = os.path.join(rel_dir, file) if rel_dir != '.' else file
                photo_files.append(rel_path)
                if '/' in rel_path:
                    folders.add(rel_path.split('/')[0])
    return render_template('gallery.html', files=photo_files, folders=sorted(folders), type='photo')

@app.route('/gallery/videos')
def gallery_videos():
    video_files = []
    for root, dirs, files in os.walk('videos'):
        for file in sorted(files):
            if file.endswith(('.mp4', '.h264')):
                path = os.path.join(root, file)
                rel_path = os.path.relpath(path, 'videos')
                video_files.append(rel_path)
    for root, dirs, files in os.walk('photos'):
        for file in sorted(files):
            if file.endswith('.mp4'):
                path = os.path.join(root, file)
                rel_path = os.path.relpath(path, 'photos')
                video_files.append('../photos/' + rel_path)
    return render_template('gallery.html', files=video_files, type='video')

@app.route('/media/photos/<path:filename>')
def media_photos(filename):
    return send_from_directory('photos', filename, as_attachment=True)

@app.route('/media/videos/<path:filename>')
def media_videos(filename):
    return send_from_directory('videos', filename, as_attachment=True)

@app.route('/recording_status')
def recording_status():
    return jsonify({
        "recording": camera_handler.is_recording(),
        "timelapse": camera_handler.is_timelapse_running(),
        "duration": camera_handler.get_recording_duration()
    })

@app.route('/convert_timelapse/<folder>')
def convert_timelapse(folder):
    def run_ffmpeg(folder):
        input_path = os.path.join('photos', folder)
        output_path = os.path.join('photos', folder + '.mp4')
        if not os.path.exists(input_path) or not os.path.isdir(input_path):
            return
        image_files = [f for f in os.listdir(input_path) if f.endswith('.jpg')]
        if len(image_files) < 2:
            return
        if os.path.exists(output_path):
            return
        subprocess.run([
            "ffmpeg", "-y", "-framerate", "10",
            "-pattern_type", "glob", "-i", os.path.join(input_path, "img_*.jpg"),
            "-c:v", "libx264", "-pix_fmt", "yuv420p",
            output_path
        ])
    threading.Thread(target=run_ffmpeg, args=(folder,), daemon=True).start()
    return ('', 204)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=False)
