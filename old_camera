# motioneye_clone/camera.py
from picamera2 import Picamera2
from picamera2.encoders import H264Encoder, Quality
from picamera2.outputs import FileOutput
import threading, time, io, os, subprocess
from datetime import datetime
from PIL import Image

class CameraHandler:
    def __init__(self):
        self.picam2 = Picamera2()
        self.settings = {
            'preview_resolution': (640, 480),
            'photo_resolution': (1920, 1080),
            'white_balance': 'auto',
            'interval': 10,  # in seconds
            'duration_minutes': 0  # 0 means run until manually stopped
        }
        self.streaming = False
        self.recording = False
        self.timelapse_running = False
        self.timelapse_thread = None
        self.timelapse_folder = None
        self._configure_camera(stream=True)

    def _configure_camera(self, stream=False):
        self.picam2.stop()
        res = self.settings['preview_resolution'] if stream else self.settings['photo_resolution']
        config = self.picam2.create_preview_configuration(main={'size': res})
        self.picam2.configure(config)
        self.picam2.start()

    def gen_frames(self):
        self._configure_camera(stream=True)
        self.streaming = True
        while self.streaming:
            frame = self.picam2.capture_array()
            img = Image.fromarray(frame).convert("RGB")
            buf = io.BytesIO()
            img.save(buf, format='JPEG')
            frame_bytes = buf.getvalue()
            yield (b'--frame\r\n'
                   b'Content-Type: image/jpeg\r\n\r\n' + frame_bytes + b'\r\n')

    def take_photo(self, custom_path=None):
        self._configure_camera(stream=False)
        if not custom_path:
            filename = datetime.now().strftime("photos/photo_%Y%m%d_%H%M%S.jpg")
        else:
            filename = custom_path
        os.makedirs(os.path.dirname(filename), exist_ok=True)
        self.picam2.capture_file(filename)

    def start_recording(self):
        self._configure_camera(stream=False)
        if not self.recording:
            filename = datetime.now().strftime("videos/video_%Y%m%d_%H%M%S.h264")
            self.encoder = H264Encoder()
            self.picam2.start_recording(self.encoder, FileOutput(filename))
            self.recording = True

    def stop_recording(self):
        if self.recording:
            self.picam2.stop_recording()
            self.recording = False

    def update_settings(self, preview_res, photo_res, white_balance, interval, duration_minutes):
        if preview_res:
            w, h = map(int, preview_res.split('x'))
            self.settings['preview_resolution'] = (w, h)
        if photo_res:
            w, h = map(int, photo_res.split('x'))
            self.settings['photo_resolution'] = (w, h)
        if white_balance:
            self.settings['white_balance'] = white_balance
        if interval:
            self.settings['interval'] = int(interval)
        if duration_minutes:
            self.settings['duration_minutes'] = int(duration_minutes)
        self._configure_camera(stream=True)

    def start_timelapse(self):
        if not self.timelapse_running:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            self.timelapse_folder = f"photos/timelapse_{timestamp}"
            os.makedirs(self.timelapse_folder, exist_ok=True)
            self.timelapse_running = True
            self.timelapse_thread = threading.Thread(target=self._timelapse_loop)
            self.timelapse_thread.start()

    def stop_timelapse(self):
        self.timelapse_running = False
        if self.timelapse_thread:
            self.timelapse_thread.join()
            self._assemble_timelapse_video()

    def _timelapse_loop(self):
        count = 0
        max_photos = 0
        if self.settings['duration_minutes'] > 0:
            max_photos = (self.settings['duration_minutes'] * 60) // self.settings['interval']

        while self.timelapse_running:
            photo_path = os.path.join(self.timelapse_folder, f"img_{count:04}.jpg")
            self.take_photo(custom_path=photo_path)
            count += 1
            if max_photos and count >= max_photos:
                break
            time.sleep(self.settings['interval'])
        self.timelapse_running = False

    def _assemble_timelapse_video(self):
        if not self.timelapse_folder:
            return
        output_path = self.timelapse_folder + ".mp4"
        try:
            subprocess.run([
                "ffmpeg", "-y", "-framerate", "10",
                "-pattern_type", "glob", "-i",
                os.path.join(self.timelapse_folder, "img_*.jpg"),
                "-c:v", "libx264", "-pix_fmt", "yuv420p",
                output_path
            ], check=True)
        except Exception as e:
            print(f"Failed to assemble timelapse video: {e}")

    def get_settings(self):
        return self.settings

